<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste do Gerenciador de Banco de Dados</title>
    <link rel="stylesheet" href="assets/css/gmp-portal.css">
    <style>
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .info { color: #17a2b8; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .warning { color: #ffc107; }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Teste do Gerenciador de Banco de Dados</h1>
        
        <div class="test-section">
            <h2>Teste de conexão</h2>
            <button onclick="testConnection()">Testar conexão com banco de dados</button>
            <button onclick="testConnectionStatus()">Verificar status da conexão</button>
            <div id="connection-results" class="test-result"></div>
        </div>
        
        <div class="test-section">
            <h2>Teste de operações básicas</h2>
            <button onclick="testCreateTable()">Criar tabela de teste</button>
            <button onclick="testInsertData()">Inserir dados de teste</button>
            <button onclick="testQueryData()">Consultar dados de teste</button>
            <button onclick="testUpdateData()">Atualizar dados de teste</button>
            <button onclick="testDeleteData()">Excluir dados de teste</button>
            <div id="basic-results" class="test-result"></div>
        </div>
        
        <div class="test-section">
            <h2>Teste de recursos avançados</h2>
            <button onclick="testTransaction()">Teste de transação</button>
            <button onclick="testBatchOperation()">Teste de operações em lote</button>
            <button onclick="testStoredProcedure()">Teste de procedimento armazenado</button>
            <div id="advanced-results" class="test-result"></div>
        </div>
        
        <div class="test-section">
            <h2>Teste de integração Oracle</h2>
            <button onclick="testOracleConnection()">Testar conexão Oracle</button>
            <button onclick="testOracleQuery()">Testar consulta Oracle</button>
            <button onclick="testOracleSync()">Testar sincronização de dados</button>
            <div id="oracle-results" class="test-result"></div>
        </div>
    </div>

    <script src="assets/js/security.js"></script>
    <script>
        let testResults = {
            connection: [],
            basic: [],
            advanced: [],
            oracle: []
        };

        function logResult(category, message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            testResults[category].push(logEntry);
            updateResults(category);
        }

        function updateResults(category) {
            const container = document.getElementById(category + '-results');
            if (container) {
                container.innerHTML = testResults[category].join('\n');
                container.scrollTop = container.scrollHeight;
            }
        }

        async function testConnection() {
            try {
                logResult('connection', 'Iniciando teste de conexão com backend...', 'info');
                const res = await fetch('/api/security/validate', { headers: securityManager.getAuthHeaders() });
                const data = await res.json();
                if (res.ok && data.valid) {
                    logResult('connection', `Backend acessível, usuário: ${JSON.stringify(data.user)}`, 'success');
                } else {
                    logResult('connection', `Token inválido ou sessão expirada: ${data.error || 'sem detalhes'}`, 'error');
                }
            } catch (error) {
                logResult('connection', `Exceção no teste de conexão: ${error.message}`, 'error');
            }
        }

        async function testConnectionStatus() {
            try {
                logResult('connection', 'Verificando status da sessão local...', 'info');
                const isAuth = securityManager.isAuthenticated();
                logResult('connection', `Sessão autenticada: ${isAuth}`, isAuth ? 'success' : 'warning');
                if (isAuth) {
                    logResult('connection', `Usuário atual: ${JSON.stringify(securityManager.getCurrentUser())}`, 'info');
                }
            } catch (error) {
                logResult('connection', `Exceção na verificação de status: ${error.message}`, 'error');
            }
        }

        async function testCreateTable() {
            try {
                logResult('basic', 'Iniciando criação de tabela de teste...', 'info');
                const createTableSQL = `
                    CREATE TABLE IF NOT EXISTS test_users (
                        id TEXT PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        email TEXT,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                        status TEXT DEFAULT 'active'
                    )
                `;
                const res = await fetch('/api/db/execute', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({ sql: createTableSQL })
                });
                const data = await res.json();
                logResult('basic', `Resultado da criação da tabela: ${JSON.stringify(data)}`, res.ok && !data.error ? 'success' : 'error');
            } catch (error) {
                logResult('basic', `Falha na criação da tabela: ${error.message}`, 'error');
            }
        }

        async function testInsertData() {
            try {
                logResult('basic', 'Iniciando inserção de dados de teste...', 'info');
                const res = await fetch('/api/db/execute', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({
                        sql: "INSERT INTO test_users (id, username, email) VALUES (?, ?, ?)",
                        params: ['user_' + Date.now(), 'testuser', 'test@example.com']
                    })
                });
                const data = await res.json();
                logResult('basic', `Resultado da inserção de dados: ${JSON.stringify(data)}`, res.ok && !data.error ? 'success' : 'error');
                if (res.ok && !data.error) {
                    logResult('basic', `Linhas inseridas: ${data.rowsAffected ?? 'N/D'}`, 'info');
                }
            } catch (error) {
                logResult('basic', `Falha na inserção de dados: ${error.message}`, 'error');
            }
        }

        async function testQueryData() {
            try {
                logResult('basic', 'Iniciando consulta de dados de teste...', 'info');
                const res = await fetch('/api/db/query', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({ sql: 'SELECT * FROM test_users' })
                });
                const result = await res.json();
                logResult('basic', `Resultado da consulta: ${JSON.stringify(result)}`, res.ok && !result.error ? 'success' : 'error');
                if (res.ok && result.rows) {
                    logResult('basic', `Consultados ${result.rows.length} registros`, 'info');
                    result.rows.forEach((row, index) => {
                        logResult('basic', `Registro ${index + 1}: ${JSON.stringify(row)}`, 'info');
                    });
                }
            } catch (error) {
                logResult('basic', `Falha na consulta de dados: ${error.message}`, 'error');
            }
        }

        async function testUpdateData() {
            try {
                logResult('basic', 'Iniciando atualização de dados de teste...', 'info');
                const res = await fetch('/api/db/execute', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({
                        sql: "UPDATE test_users SET email = 'updated@example.com' WHERE username = 'testuser'"
                    })
                });
                const data = await res.json();
                logResult('basic', `Resultado da atualização: ${JSON.stringify(data)}`, res.ok && !data.error ? 'success' : 'error');
                if (res.ok && !data.error) {
                    logResult('basic', `Linhas atualizadas: ${data.rowsAffected ?? 'N/D'}`, 'info');
                }
            } catch (error) {
                logResult('basic', `Falha na atualização de dados: ${error.message}`, 'error');
            }
        }

        async function testDeleteData() {
            try {
                logResult('basic', 'Iniciando exclusão de dados de teste...', 'info');
                const res = await fetch('/api/db/execute', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({
                        sql: "DELETE FROM test_users WHERE username = 'testuser'"
                    })
                });
                const data = await res.json();
                logResult('basic', `Resultado da exclusão: ${JSON.stringify(data)}`, res.ok && !data.error ? 'success' : 'error');
                if (res.ok && !data.error) {
                    logResult('basic', `Linhas excluídas: ${data.rowsAffected ?? 'N/D'}`, 'info');
                }
            } catch (error) {
                logResult('basic', `Falha na exclusão de dados: ${error.message}`, 'error');
            }
        }

        async function testTransaction() {
            try {
                logResult('advanced', 'Iniciando teste de transação...', 'info');
                // Se o backend não expõe transações, executamos sequência coerente
                const id2 = 'user_' + (Date.now() + 1);
                const id3 = 'user_' + (Date.now() + 2);

                const res1 = await fetch('/api/db/execute', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({ sql: "INSERT INTO test_users (id, username) VALUES (?, ?)", params: [id2, 'user2'] })
                });
                const r1 = await res1.json();

                const res2 = await fetch('/api/db/execute', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({ sql: "INSERT INTO test_users (id, username) VALUES (?, ?)", params: [id3, 'user3'] })
                });
                const r2 = await res2.json();

                const ok = !r1.error && !r2.error;
                logResult('advanced', `Resultado da "transação": ${JSON.stringify({ r1, r2 })}`, ok ? 'success' : 'error');
            } catch (error) {
                logResult('advanced', `Falha no teste de transação: ${error.message}`, 'error');
            }
        }

        async function testBatchOperation() {
            try {
                logResult('advanced', 'Iniciando teste de operações em lote...', 'info');
                const cmds = [
                    { sql: "INSERT INTO test_users (id, username) VALUES (?, ?)", params: ['user_' + (Date.now()+10), 'user4'] },
                    { sql: "INSERT INTO test_users (id, username) VALUES (?, ?)", params: ['user_' + (Date.now()+11), 'user5'] },
                    { sql: "INSERT INTO test_users (id, username) VALUES (?, ?)", params: ['user_' + (Date.now()+12), 'user6'] }
                ];
                const results = [];
                for (const c of cmds) {
                    const res = await fetch('/api/db/execute', {
                        method: 'POST',
                        headers: securityManager.getAuthHeaders(),
                        body: JSON.stringify(c)
                    });
                    results.push(await res.json());
                }
                const ok = results.every(r => !r.error);
                logResult('advanced', `Resultado das operações em lote: ${JSON.stringify(results, null, 2)}`, ok ? 'success' : 'error');
            } catch (error) {
                logResult('advanced', `Falha no teste de operações em lote: ${error.message}`, 'error');
            }
        }

        async function testStoredProcedure() {
            try {
                logResult('advanced', 'Procedimentos armazenados não são suportados em SQLite. Simulando verificação...', 'warning');
                // Caso seu backend tenha endpoint para procedure, ajuste aqui:
                // const res = await fetch('/api/db/procedure', { method: 'POST', headers: securityManager.getAuthHeaders(), body: JSON.stringify({ name: 'test_procedure', params: [] }) });
                // const data = await res.json();
                // logResult('advanced', `Resultado da procedure: ${JSON.stringify(data)}`, res.ok && !data.error ? 'success' : 'error');
            } catch (error) {
                logResult('advanced', `Falha no teste de procedimento armazenado: ${error.message}`, 'error');
            }
        }

        async function testOracleConnection() {
            try {
                logResult('oracle', 'Oracle requer configuração no backend (driver/endpoints). Verificando endpoint...', 'info');
                // Exemplo (se tiver): /api/oracle/connect
                const res = await fetch('/api/oracle/connect', { headers: securityManager.getAuthHeaders() });
                if (res.ok) {
                    const data = await res.json();
                    logResult('oracle', `Resultado da conexão Oracle: ${JSON.stringify(data)}`, data.success ? 'success' : 'warning');
                } else {
                    logResult('oracle', 'Endpoint /api/oracle/connect não disponível', 'warning');
                }
            } catch (error) {
                logResult('oracle', `Falha no teste de conexão Oracle: ${error.message}`, 'error');
            }
        }

        async function testOracleQuery() {
            try {
                logResult('oracle', 'Verificando endpoint de consulta Oracle...', 'info');
                const res = await fetch('/api/oracle/query', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({ sql: 'SELECT * FROM all_tables FETCH FIRST 5 ROWS ONLY' })
                });
                if (res.ok) {
                    const data = await res.json();
                    logResult('oracle', `Resultado da consulta Oracle: ${JSON.stringify(data)}`, data.success ? 'success' : 'warning');
                    if (data.rows) logResult('oracle', `Consultados ${data.rows.length} registros`, 'info');
                } else {
                    logResult('oracle', 'Endpoint /api/oracle/query não disponível', 'warning');
                }
            } catch (error) {
                logResult('oracle', `Falha no teste de consulta Oracle: ${error.message}`, 'error');
            }
        }

        async function testOracleSync() {
            try {
                logResult('oracle', 'Verificando endpoint de sincronização Oracle...', 'info');
                const res = await fetch('/api/oracle/sync', {
                    method: 'POST',
                    headers: securityManager.getAuthHeaders(),
                    body: JSON.stringify({ sourceTable: 'oracle_table', targetTable: 'local_table', syncMode: 'full' })
                });
                if (res.ok) {
                    const data = await res.json();
                    logResult('oracle', `Resultado da sincronização: ${JSON.stringify(data)}`, data.success ? 'success' : 'warning');
                } else {
                    logResult('oracle', 'Endpoint /api/oracle/sync não disponível', 'warning');
                }
            } catch (error) {
                logResult('oracle', `Falha no teste de sincronização de dados: ${error.message}`, 'error');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            logResult('connection', 'Página de teste do gerenciador de banco de dados carregada', 'info');
            logResult('basic', 'Teste de operações básicas pronto', 'info');
            logResult('advanced', 'Teste de recursos avançados pronto', 'info');
            logResult('oracle', 'Teste de integração Oracle pronto', 'info');
        });
    </script>
</body>
</html>
